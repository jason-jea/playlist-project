import requests
import base64
import json
import pandas
import os
import webbrowser
import urllib


# return a code from spotify that we need to use to get an auth token.
# code is generated by having a user log in with spotify credentials.
# right now, I'm popping open a browser window that you can auth with spotify.
# the redirect sends the user to a dead page,
# and then the user has to copy the code portion in the callback url to enter into their console.
def get_code(client_id, redirect_uri, scopes):   # Is there a better way to do this, that we can grab the code from the callback directly?
    params = {'response_type': 'code',
              'redirect_uri': redirect_uri,
              'client_id': client_id,  # this is grabbed from Spotify account.
              'scope': scopes}
    url = 'https://accounts.spotify.com/authorize'
    requests.get(url=url, params=params)

    auth_url = url + '?' + urllib.urlencode(params)
    webbrowser.open(auth_url)

    # user needs to copy the code portion of the url
    try:
        response = raw_input("For the url you were redirected to, enter the portion after code= : ")
    except NameError:
        response = input("For the url you were redirected to, enter the portion after code= : ")

    code = response

    return code


# based on code from callback url after user logged in, will return the auth token from Spotify
def get_token(code, client_id, client_secret, redirect_uri):
    url = 'https://accounts.spotify.com/api/token'
    payload = {
        'grant_type': 'authorization_code',
        'code': code,
        'redirect_uri': redirect_uri
    }

    # header is constructed in the format of Basic BASE64_ENCODED(client_id:client_secret)
    headers = {
        'Authorization': 'Basic ' + base64.b64encode(client_id + ':' + client_secret)
    }

    data = requests.post(url=url, data=payload, headers=headers)
    data = json.loads(data.text)

    access_token = data['access_token']  # retrieve token from json response

    return access_token


# function to retrieve all playlists for the person being authenticated.
def get_playlists():
    url = 'https://api.spotify.com/v1/me/playlists'

    # max response is 50 playlists.  offset allows us to set a "marker" where our last request left off
    # NOTE: I have a better way of coding this pattern in the get_track_info() function.
    # There's definitely some unnecessary code here.
    limit = 50
    offset = 0

    params = {'limit': limit,
              'offset': offset
              }
    data = requests.get(url=url, headers=header, params=params)
    playlist_data = json.loads(data.text)

    playlists = playlist_data['items']  # retrieve initial set of 50 playlists (stored in 'items' object) into a list

    # response contains a 'next' object that is null if there are no further playlists to retrieve
    # if it's not null, we know we increment the offset variable by a value equal to the limit
    while playlist_data['next'] is not None:
        offset = offset + limit
        params = {'limit': limit,
                  'offset': offset}
        data = requests.get(url=url, headers=header, params=params)
        playlist_data = json.loads(data.text)
        playlists = playlists + playlist_data['items']  # add additional values to playlists list object

    return playlists


# get all tracks belonging to a playlist
def get_playlist_tracks(user_id, playlist_id):
    url = 'https://api.spotify.com/v1/users/' + user_id + '/playlists/' + playlist_id + '/tracks'
    limit = 100  # max return 100 tracks
    offset = 0
    params = {'limit': limit,
              'offset': offset
              }
    data = requests.get(url=url, headers=header, params=params)
    track_data = json.loads(data.text)
    df = pandas.DataFrame(track_data['items'])

    while track_data['next'] is not None:  # while next marker exists, increment offset based on max limit
        offset = offset + limit
        params = {'limit': limit,
                  'offset': offset
                  }
        data = requests.get(url=url, headers=header, params=params)
        track_data = json.loads(data.text)
        df = df.append(pandas.DataFrame(track_data['items']))  # append to existing dataframe

    # sometimes, with offline playlists or itunes playlists, the tracks endpoint will not return anything
    # if that's the case, we want to return an empty dataframe.
    if df.empty:
        return df
    # otherwise, grab the id, name, and primary artist of each track
    else:
        track_info = pandas.DataFrame(df['track'].tolist())

        tracks = track_info[['id', 'name']]

        # getting primary artist is a little bit tricky.
        # the track_info dataframe is going to contain an artists column.
        # this artists column is a crazy nested field- essentially, it's a list of dictionaries,
        # with each dictionary representing an artist object.
        # to simplify things, we grab the first artist object, and extract the name key/value.
        # we want to do this for EACH row, so we apply a lambda function across all rows.
        artists = track_info[['artists']].apply(lambda x: x[0][0]['name'], 1)

        tracks.loc[:, 'artist'] = artists  # create a new column in the tracks dataframe for the artist names
        return tracks


# Spotify has a nifty endpoint for batch retrieving audio features for a bunch of tracks
# However, we can only retrieve for 100 tracks at a time.
def get_track_info(track_ids):
    url = 'https://api.spotify.com/v1/audio-features'

    ids = len(track_ids)  # let's store how many tracks we're trying to get feature data for
    # (this will also be a counter so we know how many tracks we have left to retrieve info for)

    feature_data = None  # initialize a variable containing nothing.  This will hold a dataframe later.

    while ids > 0:  # We are going to count backwards in 100 increments, until we've retrieved info for all tracks.
        # If we have more than 100 tracks left, we will grab another 100 of ids.
        if ids > 100:
            track_ids_small = track_ids[(ids-100):(ids-1)]
        # otherwise, we just grab whatever ids are left.
        else:
            track_ids_small = track_ids[0:(ids-1)]
        tracks = ",".join(track_ids_small)  # collapse our list of tracks into a comma delimited string
        params = {
            'ids': tracks
        }
        data = requests.get(url, params=params, headers=header)

        # if feature_data is still None, which means it's our first time through the loop,
        # set the variable to equal a dataframe of the 'audio_features' object.
        if feature_data is None:
            feature_data = pandas.DataFrame(json.loads(data.text)['audio_features'])
        # otherwise, append to existing dataframe
        else:
            feature_data = feature_data.append(pandas.DataFrame(json.loads(data.text)['audio_features']))

        # if we had more than 100 tracks left, we can decrease the ids counter by 100 for the next iteration.
        if ids > 100:
            ids = ids - 100
        # otherwise, set the ids to 0, since we are done
        else:
            ids = 0

    return feature_data


# primary script to create a tidy dataframe for playlists track info
# each row is a track for a playlist
# each column is a feature or characteristic of that track
def main():
    # retrieve client_id and client_secrete.  These can be found on the developer app page in Spotify.
    # I store them as environment variables for easy and safe access.
    client_id = os.getenv('SPOTIFY_CLIENT_ID')
    client_secret = os.getenv('SPOTIFY_CLIENT_SECRET')

    # Since I don't have a proper web app set up, I redirect to localhost after authentication.
    # It's not a valid url, but I just need to copy out the code snippet after the redirect.
    redirect_uri = 'http://localhost/'

    # define scope for our user
    scopes = 'playlist-read-private playlist-read-collaborative'

    # get code
    code = get_code(client_id=client_id, redirect_uri=redirect_uri, scopes=scopes)

    # exchange code for token
    token = get_token(code=code, client_id=client_id, client_secret=client_secret, redirect_uri=redirect_uri)

    # set our header for all future requests
    global header
    header = {'Authorization': 'Bearer ' + token}

    # grab all playlists for current user
    # the returned dataframe should include playlist name, playlist id, and the owner of the playlist.
    playlists = get_playlists()

    # instantiate an empty dataframe with correct columns
    playlist_track_data = pandas.DataFrame(columns=['acousticness', 'analysis_url', 'danceability', 'duration_ms',
                                                    'energy', 'track_id', 'instrumentalness', 'key', 'liveness',
                                                    'loudness', 'mode', 'speechiness', 'tempo', 'time_signature',
                                                    'track_href', 'type', 'uri', 'valence', 'playlist_name',
                                                    'playlist_id', 'user_id'])

    # loop through playlists to build track data
    for playlist in playlists:
        playlist_id = playlist['id']  # store playlist id, name, and owner into separate variables
        playlist_name = playlist['name']
        user_id = playlist['owner']['id']

        # print the playlist id and owner for easier debugging
        print playlist_id, user_id

        # get all tracks for a playlist
        # returns dataframe with the track id
        tracks = get_playlist_tracks(user_id=user_id, playlist_id=playlist_id)

        # if we get back an empty frame, means that spotify couldn't find any tracks for that playlist id.
        # continue onto next iteration
        if tracks.empty:
            continue

        # sometimes, the playlist actually has tracks,
        # but because it's an offline playlist, spotify can't retrieve the id.
        # we'll filter our tracks dataframe to only contain rows where the id is not null.
        tracks = tracks[tracks['id'].notnull()]

        # if resulting filtered dataframe is empty, continue to next iteration.
        if tracks.empty:
            continue

        # if everything checks out, build a dataframe that grabs feature data for every track
        track_features = get_track_info(tracks['id'])

        # then adds columns for the playlist_name, playlist_id, and owner user_id
        track_features.loc[:, 'playlist_name'] = playlist_name
        track_features.loc[:, 'playlist_id'] = playlist_id
        track_features.loc[:, 'user_id'] = user_id
        track_features = track_features.rename(columns={'id': 'track_id'})

        # append current iteration playlist track feature data to the playlist_track_data dataframe
        playlist_track_data = playlist_track_data.append(track_features)

    # write final playlist track dataframe to a txt fle
    playlist_track_data.to_csv(os.path.expanduser('~/playlist-project/playlist_track_data.txt'),
                               sep='\t',
                               encoding='utf-8')


main()
